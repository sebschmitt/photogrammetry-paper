% !TeX root = ../../main.tex
\ohead{Sebastian Schmitt}

\chapter{Umsetzung}\label{sec:implementation}
Im folgenden wird der Aufbau des Projektes sowie verwendete Bibliotheken erläutert.
Zusätzlich wird auf die Implementierung der einzelnen Schritte der SfM Pipeline eingegangen.

\section{Projektstruktur}
Die Applikation wird in C++ entwickelt.
Auch wenn Performance kein Ziel ist, wurde C++ gewählt um eine höhere Performance zu erreichen.
Einzige Abhängigkeit ist die offene Bibliothek OpenCV, siehe dazu \ref{sec:opencv}.
Zur Buildsteuerung wird das quelloffene Tool CMake\footnote{https://cmake.org/} verwendet.

Das Projekt ist folgendermaßen strukturiert:

\dirtree{%
.1 yapgt.
.2 include \ldots{} \begin{minipage}[t]{12cm}
Header-Dateien
\end{minipage}.
.2 resources \ldots{} \begin{minipage}[t]{12cm}
Bilder zum Testen von Kalibrierung und Feature-Matching
\end{minipage}.
.2 src \ldots{} \begin{minipage}[t]{12cm}
Implementierung
\end{minipage}.
.2 CMakeLists.txt \ldots{} \begin{minipage}[t]{12cm}
CMake Konfiguration
\end{minipage}.
}


\section{OpenCV}\label{sec:opencv}
Es wird OpenCV in der Version 4.2.0 mit dem Modul OpenCV Contrib verwendet.
OpenCV Contrib beinhaltet OpenCV Module, welche jedoch nicht stabil genug sind um Teil der offiziellen OpenCV Distribution zu sein \cite[README.md]{opencv_2013}.
OpenCV wurde mit folgenden Optionen kompiliert:
\begin{itemize}
	\item OPENCV\_EXTRA\_MODULES\_PATH um den Pfad zu OpenCV Contrib festzulegen
	\item OPENCV\_ENABLE\_NONFREE um auch nicht freie Algorithmen zu kompilieren
\end{itemize}
Auch wenn es Anforderung ist nur freie Bibliotheken zu verwenden, ist der Flag OPENCV\_ENABLE\_NON\_FREE notwendig.
Der in dieser Arbeit verwendete Algorithmus Scale-Invariant Feature Transform (SIFT) war bis 06. März 2020 von der University of British Columbia patentiert\footnote{siehe dazu https://patents.google.com/patent/US6711293} und ist daher in der verwendeten OpenCV Version nur mit OPENCV\_ENABLE\_NON\_FREE nutzbar.
SIFT ist Teil des Moduls Features2D extra (xfeatures2d) welches Teil von OpenCV Contrib ist und sowohl experimentelle als auch nicht freie Algorithmen beinhaltet.

Um die Applikation auch nutzen zu können ohne vorab OpenCV zu installieren oder zu kompilieren wurde CMake angewiesen, OpenCV statisch zu linken (siehe \autoref{lst:cmake_opencv_static}, Zeilen 1-4).
Zusätzlich kopiert CMake alle gelinkten Bibliotheken, auch wenn diesen nicht referenziert werden, in den Ausgabeordner, damit diese nicht von Hand kopiert werden müssen (\autoref{lst:cmake_opencv_static}, Zeilen 6-8).

\begin{lstlisting}[numbers=left, breaklines=true,breakatwhitespace=false,label=lst:cmake_opencv_static, caption=Ausschnitt von CMakeLists.txt um OpenCV statisch zu linken]
set(OPENCV_STATIC ON)
find_package(OpenCV REQUIRED)
[..]
target_link_libraries(yapgt ${OpenCV_LIBS})
[..]
foreach(CVLib ${OpenCV_LIBS})
    file(COPY ${_OpenCV_LIB_PATH}/${CVLib}${OpenCV_VERSION_MAJOR}${OpenCV_VERSION_MINOR}${OpenCV_VERSION_PATCH}d.dll DESTINATION ${CMAKE_BINARY_DIR})
endforeach()
\end{lstlisting}


\section{Kommandozeilenargumente}
Die einzelnen Schritte der Pipeline werden mittels Kommandozeilenargumente konfiguriert.
Zum Parsen der übergebenen Argumente wurde ein Argumentparser geschrieben.
Dieser akzeptiert Argumente in der Form \emph{-Argumentname}, wobei es egal ist wie viele Bindestriche vor dem Argumentnamen stehen.
Da nach jedem Bindestrich ein neues Argument beginnt, ist es nicht möglich Bindestriche innerhalb von Argumentnamen zu verwenden.
Dieser ist in \emph{include/argparser.hpp} spezifiziert und in \emph{src/argparser.c} implementiert.
Er beinhaltet den Namespace \emph{argparser} sowie zwei Klassen:
\begin{itemize}
\item \textbf{Argument}, repräsentiert ein Arguments (Name, Beschreibung, ob es übergeben wurde, welcher Wert übergeben wurde, ob es übergeben werden muss)
\item \textbf{ArgumentParser}, kennt alle Argumente, überprüft die übergebenen Argumente und legt fest ob und wie ein Argument übergeben wurde
\end{itemize}

Damit der \emph{ArgumentParser} auf Attribute von \emph{Argumenten} zugreifen darf, welche nicht öffentlich sein sollen, wurden diese als \emph{protected} markiert und \emph{ArgumentParser} innerhalb der Klasse \emph{Argument} als \emph{Friend Class} markiert (siehe dazu \autoref{lst:argparser_argument_friend}, Zeilen 2-3).
Auch wenn der übergebene Wert intern als String repräsentiert wird, kann er mit der Funktion \emph{getValue()} auch in andere primitive Typen konvertiert werden (\autoref{lst:argparser_argument_friend}, Zeilen 7-12).

\begin{lstlisting}[language=c++, numbers=left, breaklines=true, breakatwhitespace=false, label=lst:argparser_argument_friend]
namespace argparser {
    class Argument {
        friend class ArgumentParser;

    public:
        [..]
        template<typename T> T getValue() {
            std::istringstream in(this->value);
            T t = T();
            in >> t >> std::ws;
            return t;
        }
        [..]
    protected:
        std::string value;
        [..]
    };
    [..]
}
\end{lstlisting}

\begin{lstlisting}[language=c++, numbers=left, breaklines=true, breakatwhitespace=false, label=lst:argparser_example, caption=Argparser Verwendung]
int main(int argc, char *argv[]) {
    argparser::ArgumentParser parser("yapgt (yet another photogrammetry tool)");
    argparser::Argument a_loadCalibration("loadCalibration", "Filepath to load calibration from");    
    parser.addArgument(&a_loadCalibration);
    parser.parseArguments(argc, argv);
    if (a_loadCalibration.isFound()) {
        filesystem::path path(a_loadCalibration.getValue<string>());
    }
}
\end{lstlisting}

Der Argumentparser kann wie in \autoref{lst:argparser_example} zu sehen ist verwendet werden:\\
Zunächst wird eine Instanz von \emph{ArgumentParser} erzeugt.
Als Parameter wird der Applikationsname übergeben.
Dieser wird beim Aufruf der Applikation mit dem Argument \emph{-help} angezeigt.
Danach wird ein Argument erzeugt.
Als Parameter werden der Name des Argumentes, sowie eine Beschreibung für Hilfe übergeben.
Danach wird das Argument dem ArgumentParser hinzugefügt.
Mit der Funktion \emph{parseArguments(argc, argv)} wird das eigentliche Verarbeiten der Argumente durchgeführt.
Mittels der Funktion \emph{isFound()} wird nun überprüft, ob das Argument übergeben wurde.
Der übergebene Wert kann nun mittels \emph{getValue<string>()} als String weiter verarbeitet werden.

In \autoref{tab:arguments} sind alle verfügbaren Argumente so wie eine Beschreibung aufgelistet.

\begin{table}[]
\centering
\begin{tabularx}{\textwidth}{ |l|X| }
\hline
Name              & Beschreibung                                                                                                              \\ \hline
loadCalibration   & Dateipfad, aus dem die Kalibrierung geladen wird, kann nicht gleichzeitig mit calibrationImages werden                    \\
saveCalibration   & Dateipfad, in dem die Kalibrierung gespeichert wird                                                                       \\
calibrationImages & Ordnerpfad, Bilder welche zur Kalibrierung verwendet werden, kann nicht gleichzeitig mit loadCalibration verwendet werden \\
calibrateRow      & Anzahl der Zeilen des Kalibrierungsmusters                                                                                \\
calibrateColumn   & Anzahl der Spalten des Kalibrierungsmusters                                                                               \\
matchImages       & Ordnerpfad, Bilder, welche zum Matching verwendet werden                                                                  \\
out               & Dateipfad, in den die Punkte exportiert werden                                                                            \\
matchOutput       & Ordnerpfad, visueller Export aller Matches                                                                                \\ \hline
\end{tabularx}
\caption{Übersicht über alle verfügbaren Argumente}
\label{tab:arguments}
\end{table}

\section{Kamera Kalibrierung}
Die Kalibrierung der Kamera wird von der Klasse \emph{Calibration} durchgeführt.
\emph{KameraMatrix}, \emph{OptimalMatrix} sowie \emph{DistoritonCoefficients} werden in selbiger vorgehalten, so dass einfach ein \emph{Calibration} Objekt an die weiteren Schritte der Pipeline weitergeleitet werden.
Die Klasse \emph{Calibration} ist in \emph{include/calibration.hpp} spezifiziert und in \emph{src/calibration.cpp} implementiert.
Der Konstruktor benötigt keine Argumente.
Die Klasse stellt folgende Methoden zur Verfügung:
\begin{itemize}
\item \emph{cv::Mat\& getCameraMatrix()} gibt die Kamera-Matrix zurück
\item \emph{void calibrate(std::vector<std::filesystem::path> imageFiles, cv::Size boardSize)} führt die eigentliche Kalibrierung der Kamera anhand der übergebenen Bilder durch, siehe dazu \autoref{sec:calibration-calibration}
\item \emph{void loadCalibration(std::filesytem::path filepath)} Lädt die Kalibrierung aus der angegebenen Datei, siehe dazu \autoref{sec:calibration-load-save}
\item \emph{void saveCalibration(std::filesystem::path filepath)} Speichert die Kalibrierung in der angegebenen Datei, siehe dazu \autoref{sec:calibration-load-save}
\item \emph{void undistortImage(const cv::Mat\& image, cv::Mat\& undistoredImage)} entzerrt das übergebene Bild und speichert das entzerrte Bild in \emph{undistoredImage}
\end{itemize}

\subsection{Kalibrierung}\label{sec:calibration-calibration}


\subsection{Speichern und Laden}\label{sec:calibration-load-save}
Zum Speichern und zum Laden wird OpenCVs \emph{FileStorage} verwendet.
Dieser unterstützt die Dateiformate \emph{XML}, \emph{YAML} sowie \emph{JSON}.
Konkret gespeichert werden die Matrizen \emph{cameraMatrix}, \emph{optimalCameraMatrix} sowie \emph{distortionCoefficients}.
Für jede dieser Variablen wurde eine Konstante definiert welche dem FileStorage als Schlüssel dient.
In \autoref{lst:opencv_filestorage} ist zu sehen, wie mit einem \emph{FileStorage} Objekt gearbeitet werden kann.
Bei \emph{cameraMatrixSerName}, \emph{optimalMatrixSerName} sowie \emph{distortionCoefficientsSerName} handelt es sich dabei um die konstanten Schlüssel unter welchen die Daten abgespeichert werden.
Zu beachten ist, dass beim Erzeugen des \emph{FileStorage} Objekts kein Format angegeben wurde.
Das zu verwendende Format wird anhand der Dateiendung bestimmt.

\begin{lstlisting}[language=c++, numbers=left, breaklines=true, breakatwhitespace=false, label=lst:opencv_filestorage, caption=Schreiben mit OpenCV Filestorage]
cv::FileStorage fs(filepath.string(), cv::FileStorage::WRITE);
fs << cameraMatrixSerName << cameraMatrix;
fs << optimalMatrixSerName << optimalCameraMatrix;
fs << distortionCoefficientsSerName << distortionCoefficients;
fs.release();
\end{lstlisting}

Analog zum Speichern kann \emph{FileStorage} zum Lesen verwendet werden (siehe \autoref{lst:opencv_filestorage_read}.
Dafür kann man auf das \emph{FileStorage} Objekt wie auf ein assoziatives Array zugreifen (Zeile 2).
Zusätzlich kann dann der Typ des Rückgabewerts festgelegt werden.
In diesem Beispiel wird der unter dem Schlüssel \emph{cameraMatrixSerName} gespeicherte Wert als OpenCV Matrix geliefert.

\begin{lstlisting}[language=c++, numbers=left, breaklines=true, breakatwhitespace=false, label=lst:opencv_filestorage_read, caption=Lesen mit OpenCV Filestorage]
FileStorage fs(filepath.string(), FileStorage::READ);
cameraMatrix = fs[cameraMatrixSerName].mat();
[..]
fs.release();
\end{lstlisting}


Eine von \emph{FileStorage} erzeugte XML Datei ist in \autoref{lst:opencv_filestorage_output} zu sehen.




\section{Feature Identifizierung}

\section{Feature Matching}

\section{Rekonstruktion}

\section{Export}
\subsection{PLY Format}
\subsection{Farben}

% !TeX root = ../../main.tex
\ohead{Sebastian Schmitt}

\chapter{Umsetzung}
Im folgenden wird der Aufbau des Projektes sowie verwendete Bibliotheken erläutert.
Zusätzlich wird auf die Implementierung der einzelnen Schritte der SfM Pipeline eingegangen.

\section{Projektstruktur}
Die Applikation wird in C++ entwickelt.
Auch wenn Performance kein Ziel ist, wurde C++ gewählt um eine höhere Performance zu erreichen.
Einzige Abhängigkeit ist die offene Bibliothek OpenCV, siehe dazu \ref{sec:opencv}.
Zur Buildsteuerung wird das quelloffene Tool CMake verwendet.

Das Projekt ist folgendermaßen strukturiert:

\dirtree{%
.1 yapgt.
.2 include \ldots{} \begin{minipage}[t]{12cm}
Header-Dateien
\end{minipage}.
.2 resources \ldots{} \begin{minipage}[t]{12cm}
Bilder zum Testen von Kalibrierung und Feature-Matching
\end{minipage}.
.2 src \ldots{} \begin{minipage}[t]{12cm}
Implementierung
\end{minipage}.
.2 CMakeLists.txt \ldots{} \begin{minipage}[t]{12cm}
CMake Konfiguration
\end{minipage}.
}


\subsection{OpenCV}\label{sec:opencv}
Es wird OpenCV in der Version 4.2.0 mit dem Modul OpenCV Contrib verwendet.
OpenCV Contrib beinhaltet OpenCV Module, welche jedoch nicht stabil genug sind um Teil der offiziellen OpenCV Distribution zu sein \cite[README.md]{opencv_2013}.
OpenCV wurde mit folgenden Optionen kompiliert:
\begin{itemize}
	\item OPENCV\_EXTRA\_MODULES\_PATH um den Pfad zu OpenCV Contrib festzulegen
	\item OPENCV\_ENABLE\_NONFREE um auch nicht freie Algorithmen zu kompilieren
\end{itemize}
Auch wenn es Anforderung ist nur freie Bibliotheken zu verwenden, ist der Flag OPENCV\_ENABLE\_NON\_FREE notwendig.
Der in dieser Arbeit verwendete Algorithmus Scale-Invariant Feature Transform (SIFT) war bis 06. März 2020 von der University of British Columbia patentiert\footnote{siehe dazu https://patents.google.com/patent/US6711293} und ist daher in der verwendeten OpenCV Version nur mit OPENCV\_ENABLE\_NON\_FREE nutzbar.
SIFT ist Teil des Moduls Features2D extra (xfeatures2d) welches Teil von OpenCV Contrib ist und sowohl experimentelle als auch nicht freie Algorithmen beinhaltet.

Um die Applikation auch nutzen zu können ohne vorab OpenCV zu installieren oder zu kompilieren wurde CMake angewiesen, OpenCV statisch zu linken (siehe \autoref{lst:cmake_opencv_static}, Zeilen 1-4).
Zusätzlich kopiert CMake alle gelinkten Bibliotheken, auch wenn diesen nicht referenziert werden, in den Ausgabeordner, damit diese nicht von Hand kopiert werden müssen (\autoref{lst:cmake_opencv_static}, Zeilen 6-8).

\begin{lstlisting}[numbers=left, breaklines=true,breakatwhitespace=false,label=lst:cmake_opencv_static, caption=Ausschnitt von CMakeLists.txt um OpenCV statisch zu linken]
set(OPENCV_STATIC ON)
find_package(OpenCV REQUIRED)
[..]
target_link_libraries(yapgt ${OpenCV_LIBS})
[..]
foreach(CVLib ${OpenCV_LIBS})
    file(COPY ${_OpenCV_LIB_PATH}/${CVLib}${OpenCV_VERSION_MAJOR}${OpenCV_VERSION_MINOR}${OpenCV_VERSION_PATCH}d.dll DESTINATION ${CMAKE_BINARY_DIR})
endforeach()
\end{lstlisting}


\section{Kommandozeilenargumente}
Die einzelnen Schritte der Pipeline werden mittels Kommandozeilenargumente konfiguriert.
Zum Parsen der übergebenen Argumente wurde ein Argumentparser geschrieben.
Dieser ist in \emph{include/argparser.hpp} spezifiert und in \emph{src/argparser.c} implementiert.
Er beinhaltet den Namespace \emph{argparser} sowie zwei Klassen:
\begin{itemize}
\item \textbf{Argument}, repräsentiert ein Arguments (Name, Beschreibung, ob es übergeben wurde, welcher Wert übergeben wurde, ob es übergeben werden muss)
\item \textbf{ArgumentParser}, kennt alle Argumente, überprüft die übergebenen Argumente und legt fest ob und wie ein Argument übergeben wurde
\end{itemize}

Damit der \emph{ArgumentParser} auf Attribute von \emph{Argumenten} zugreifen darf, welche nicht öffentlich sein sollen, wurden diese als \emph{protected} markiert und \emph{ArgumentParser} innerhalb der Klasse \emph{Argument} als \emph{Friend Class} markiert (siehe dazu \autoref{lst:argparser_argument_friend}, Zeilen 2-3).
Auch wenn der übergebene Wert intern als String repräsentiert wird, kann er mit der Funktion \emph{getValue()} auch in andere primitive Typen konvertiert werden (\autoref{lst:argparser_argument_friend}, Zeilen 7-12).

\begin{lstlisting}[language=c++, numbers=left, breaklines=true, breakatwhitespace=false, label=lst:argparser_argument_friend]
namespace argparser {
    class Argument {
        friend class ArgumentParser;

    public:
        [..]
        template<typename T> T getValue() {
            std::istringstream in(this->value);
            T t = T();
            in >> t >> std::ws;
            return t;
        }
        [..]
    protected:
        std::string value;
        [..]
    };
    [..]
}
\end{lstlisting}

\begin{lstlisting}[language=c++, numbers=left, breaklines=true, breakatwhitespace=false, label=lst:argparser_example, caption=Argparser Verwendung]
int main(int argc, char *argv[]) {
    argparser::ArgumentParser parser("yapgt (yet another photogrammetry tool)");
    argparser::Argument a_loadCalibration("loadCalibration", "Filepath to load calibration from");    
    parser.addArgument(&a_loadCalibration);
    parser.parseArguments(argc, argv);
    if (a_loadCalibration.isFound()) {
        filesystem::path path(a_loadCalibration.getValue<string>());
    }
}
\end{lstlisting}

Der Argumentparser kann wie folgt benutzt werden:\\
Zunächst wird eine Instanz von \emph{ArgumentParser} erzeugt.
Als Parameter wird der Applikationsname übergeben.
Dieser wird beim Aufruf der Applikation mit dem Argument \emph{-help} angezeigt.
Danach wird ein Argument erzeugt.
Als Parameter werden der Name des Argumentes, sowie eine Beschreibung für Hilfe übergeben.
Danach wird das Argument dem ArgumentParser hinzugefügt.
Mit der Funktion \emph{parseArguments(argc, argv)} wird das eigentliche Verarbeiten der Argumente durchgeführt.
Mittels der Funktion \emph{isFound()} wird nun überprüft, ob das Argument übergeben wurde.
Der übergebene Wert kann nun mittels \emph{getValue<string>()} als String weiter verarbeitet werden.

\section{Kamera Kalibrierung}

\section{Feature Identifizierung}

\section{Feature Matching}

\section{Rekonstruktion}

\section{Export}
\subsection{PLY Format}
\subsection{Farben}